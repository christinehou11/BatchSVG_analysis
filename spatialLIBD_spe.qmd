---
title: "spatialLIBD Dataset"
format: html
---

### Introduction

In this section, we will include biased feature identification analysis using our developed method to show how `BatchSVG` helps to detect and visualize the biased features in SVGs. We will use the \`spatially-resolved transcriptomics (SRT) dataset from the [spatialLIBD](https://research.libd.org/spatialLIBD/) package.

```{r load packages, message=FALSE, warning=FALSE}
library(spatialLIBD)
library(nnSVG)
library(scater)
library(here)
library(PRECAST)
library(Seurat)
library(BatchSVG)
```

The `spatialLIBD` dataset was collected from the brain region of dorsolateral prefontal cortex (dlPFC) and was also sequenced with 10X Visium. This dataset has 3 subjects and 4 samples from each subject. Because there was no slide metadata available, we investigated whether `batch = subject` influenced the top features.

```{r load data, comment=NA, warning=FALSE, message=FALSE}
# load example dataset from spatialLIBD package
# see '?spatialLIBD' for more details
spatialLIBD_spe <- fetch_data(type = "spe")

dim(spatialLIBD_spe)

table(colData(spatialLIBD_spe)[,c("sample_id","subject")])
```

### Before `BatchSVG` implementation

We will use the spatially variable genes set generated. The result is generated from [nnSVG](https://www.nature.com/articles/s41467-023-39748-z) package.

#### Preprocessing

```{r nnsvg preprocessing, message=FALSE, warning=FALSE}
# see '?nnSVG' for more details

# keep only spots over tissue
spatialLIBD_spe_1 <- spatialLIBD_spe[, colData(spatialLIBD_spe)$in_tissue == 1]
dim(spatialLIBD_spe_1) # 33538 47681

# filter any new zeros created
# remove genes with zero expression
ix_zero_genes <- rowSums(counts(spatialLIBD_spe_1)) == 0
table(ix_zero_genes)
if (sum(ix_zero_genes) > 0) {
  spatialLIBD_spe_2 <- spatialLIBD_spe_1[!ix_zero_genes, ]
}
dim(spatialLIBD_spe_2) # 25615 47681

# remove spots with zero expression
ix_zero_spots <- colSums(counts(spatialLIBD_spe_2)) == 0
table(ix_zero_spots)
if (sum(ix_zero_spots) > 0) {
  spatialLIBD_spe_3 <- spatialLIBD_spe_2[, !ix_zero_spots]
}
# ix_zero_spots
# FALSE 
# 47681
spatialLIBD_spe_filtered <- spatialLIBD_spe_2
dim(spatialLIBD_spe_filtered)

sample_ids <- levels(factor(colData(spatialLIBD_spe_filtered)$sample_id))
sample_ids
```

#### Run `nnSVG` per sample and store lists of top SVGs

```{r nnsvg per sample, eval=FALSE}
# Here we offer a pseducode example demonstrating how to run `nnSVG` for multiple samples.

res_list <- as.list(rep(NA, length(sample_ids)))
names(res_list) <- sample_ids

for (s in seq_along(sample_ids[1:2])) {
  
  # select sample
  ix <- colData(spatialLIBD_spe_filtered)$sample_id == sample_ids[s]
  spe_sub <- spatialLIBD_spe_filtered[, ix]
  dim(spe_sub)
  
  # run nnSVG filtering for mitochondrial genes and low-expressed genes
  spe_sub <- filter_genes(
    spe_sub, 
    filter_genes_ncounts = 3, 
    filter_genes_pcspots = 0.5, 
    filter_mito = TRUE
  )
  
  # remove any zeros introduced by filtering
  ix_zeros <- colSums(counts(spe_sub)) == 0
  if (sum(ix_zeros) > 0) {
    spe_sub <- spe_sub[, !ix_zeros]
  }
  dim(spe_sub)
  
  # re-calculate logcounts after filtering
  spe_sub <- computeLibraryFactors(spe_sub)
  spe_sub <- logNormCounts(spe_sub)
  
  # run nnSVG
  set.seed(123)
  spe_sub <- nnSVG(spe_sub)
  
  # store results for this sample
  res_list[[s]] <- rowData(spe_sub)
}
```

Then, combine the results across multiple samples by averaging the ranks of the SVGs following the steps showing in the `nnSVG` [vignette](https://github.com/lmweber/nnSVG/blob/4e6427e58e6c77119d1d74237c540abc6bfa8713/vignettes/nnSVG.Rmd#L476).

```{r nnsvg combine, eval=FALSE}
# number of genes that passed filtering (and subsampling) for each sample
sapply(res_list, nrow)

# match results from each sample and store in matching rows
res_ranks_LIBD <- matrix(NA, nrow = nrow(spatialLIBD_spe_filtered), ncol = length(sample_ids))
rownames(res_ranks_LIBD) <- rownames(spatialLIBD_spe_filtered)
colnames(res_ranks_LIBD) <- sample_ids

for (s in seq_along(sample_ids)) {
  stopifnot(colnames(res_ranks_LIBD)[s] == sample_ids[s])
  stopifnot(colnames(res_ranks_LIBD)[s] == names(res_list)[s])
  
  rownames_s <- rownames(res_list[[s]])
  res_ranks_LIBD[rownames_s, s] <- res_list[[s]][, "rank"]
}

# remove genes that were filtered out in all samples
ix_allna <- apply(res_ranks_LIBD, 1, function(r) all(is.na(r)))
res_ranks_LIBD <- res_ranks_LIBD[!ix_allna, ]
head(res_ranks_LIBD)
```

```{r load nnsvg, comment=NA, warning=FALSE, message=FALSE, echo=FALSE}
res_ranks_LIBD <- read.csv(here("data/libd-all_nnSVG_p-05-features-df.csv"),
    row.names = 1, check.names = FALSE)

nrow(res_ranks_LIBD)

head(res_ranks_LIBD)
```

#### Clustering

```{r clustering before, comment=NA, message=FALSE, warning=FALSE, eval=FALSE}
l2 = unique(spatialLIBD_spe_filtered$subject)
names(l2) = l2
l2 = lapply(l2, function(x) spatialLIBD_spe_filtered[,colData(spatialLIBD_spe_filtered)$subject==x])

srt.sets = lapply(l2, function(x) {
  colnames(counts(x)) <- rownames(colData(x))
  colData(x)$col <- x$array_col
  colData(x)$row <- x$array_row
  count <- counts(x)
  a1 <- CreateAssayObject(count, assay = "RNA", min.features = 0, min.cells = 0)
  CreateSeuratObject(a1, meta.data = as.data.frame(colData(x)))
})

#run precast
preobj <- CreatePRECASTObject(seuList = srt.sets,
                              customGenelist=rownames(spatialLIBD_spe_filtered),
                              premin.spots=0, premin.features=0, postmin.spots=0, postmin.features=0)
PRECASTObj <- AddAdjList(preobj, platform = "Visium")
PRECASTObj <- AddParSetting(PRECASTObj, maxIter = 20, verbose = TRUE, Sigma_equal=FALSE, coreNum=12)
PRECASTObj <- PRECAST(PRECASTObj, K=7)

#consolidate/ reformat results
PRECASTObj <- SelectModel(PRECASTObj, criteria="MBIC")
seuInt <- IntegrateSpaData(PRECASTObj, species = "Human")

write.csv(seuInt@meta.data, "findBiasedFeatures/processed-data/seuInt-hpc_k-7_svgs_metadata.csv", row.names=T)
```


### `BatchSVG` implementation

#### Installation

(After accepted in [Bioconductor](https://bioconductor.org/)).

```{r install bioc, eval=FALSE}
if (!requireNamespace("BiocManager")) {
    install.packages("BiocManager")
}
BiocManager::install("BatchSVG")
```

Install the development version from [GitHub](https://christinehou11.github.io/BatchSVG).

```{r install github, eval = FALSE}
remotes::install("christinehou11/BatchSVG")
```

#### `BatchSVG::featureSelect()`: Perform Feature Selection

We first applied `featureSelect()` function from `BatchSVG` package to compute the number of standard deviations for the relative change in deviance (**nSD_dev_subject**) and rank difference (**nSD_rank_subject**) for `batch = subject`.

```{r feature select, comment = NA, warning=FALSE}
list_batch_df <- featureSelect(input = spatialLIBD_spe, 
    batch_effect = "subject", VGs = res_ranks_LIBD$gene_id)
```

```{r feature select class, comment = NA, warning=FALSE}
class(list_batch_df)
```

```{r feature select print, comment = NA, warning=FALSE}
head(list_batch_df$subject)
```

#### `BatchSVG::svg_nSD()`: Visualize SVG Selection for Batch Effect(s)

We utilized `svg_nSD()` function to generate visualizations for batch effects 
assessments in spatially variable genes (SVGs). 

```{r svg_nSD, comment=NA, warning=FALSE, message=FALSE}
plots <- svg_nSD(list_batch_df = list_batch_df, 
            sd_interval_dev = 4, sd_interval_rank = 6)
```

*Figure 1. Visualizations of nSD_dev and nSD_rank threshold selection*

```{r figure 1, warning=FALSE, message=FALSE, fig.width=10, fig.height=8}
plots$subject
```

#### `BatchSVG::biasDetect()`: Identify Biased Genes

Using `nSD_svg()` function, we determined that `nSD_dev = 4` and `nSD_rank = 6`. 
Then, we can applied `biasDetect()` function on `spe` object to identify and 
filter out biased genes. We used both thresholds (`threshold = "both"`) and 
customized the plot color (`plot_palette = "RdPu"`), the point shape
and shape (`plot_point_shape = 23`), and the text size for biased genes 
(`plot_text_size = 4`).

```{r biasDetect, comment = NA, message=FALSE, warning=FALSE}
bias_both <- biasDetect(list_batch_df = list_batch_df, threshold = "both",
    nSD_dev = 4, nSD_rank = 6, plot_point_shape = 23, plot_palette = "RdPu",
    plot_text_size = 4)
```

*Table 1. Outlier Genes defined by nSD_dev and nSD_rank*

```{r table 1, comment = NA, message=FALSE, warning=FALSE}
head(bias_both$subject$Table)
```

*Figure 2. Outlier Genes defined by nSD_dev and nSD_rank*

```{r figure 2, message=FALSE, warning=FALSE, fig.width= 10, fig.height=4}
bias_both$subject$Plot
```


### After `BatchSVG` implementation

#### Refined SVGs

Finally, we obtain a refined set of spatially variable genes (SVGs) by removing the identified outliers based on user-defined thresholds for `nSD_dev` and `nSD_rank`.

```{r new svgs, comment = NA, message=FALSE, warning=FALSE}
bias_both_df <- bias_both$subject$Table
svgs_filt <- setdiff(res_ranks_LIBD$gene_id, bias_both_df$gene_id)
svgs_filt_spe <- res_ranks_LIBD[res_ranks_LIBD$gene_id %in% svgs_filt, ]
nrow(svgs_filt_spe)
```

#### Clustering

After obtaining the refined set of SVGs, these genes can be further analyzed using established spatial transcriptomics clustering algorithms to explore tissue layers and spatial organization.

```{r clustering after, comment=NA, message=FALSE, warning=FALSE}
```

### `R` session information {.unnumbered}

```{r session info}
## Session info
sessionInfo()
```
